# 关于配置表

> 前言：我们想要有一个方便的配置表功能，应当满足
>
> - 简单：对策划友好 ，策划只需要关注配置表的格式和内容，然后点击`一键导表`即可以在游戏中看到效果。
> - 完善：应当支持多种数据类型，数组，结构体等
> - 性能：占用内存和存取速度
> - 可热重载

## 基本格式

简单定义一个配置表的基本格式

- 第一行，定义该列的数据类型，与C#代码类型对应，`int`,`bool`,`float`,`string`,etc.
- 第二行，定义该列的字段名称，对应C#代码的字段名。
- 之后每一行，定义具体的数据，每一行都是一条数据。
- 支持行注释。

## 以原始TXT表

首先为每张表生成对应类，基类有一个`Get`方法，即

```c#
T{
    int param0;
    long param1;
}
T Get<T>(int id)
```

调用`Get`时，打开IO读取对应的txt文件流，写入对应的单例实例中。

可有一个`PreLoadAll`方法，提前加载好所有表。

- 慢，每次都要开文件IO。并且原生txt文件逐文本读也很慢。

## 以原生内存中

简单来说就是有一个集合，集合是字典或者列表

有一个对应表的类

然后，要么生成内嵌代码，初始化的时候塞进去。拆解为独立dll

- 加载很快，原生代码级别
- 占代码空间，尤其是表很大、字符串很多的情况下，dll会很大。
- 无法热重载，因为每次都得重新编译dll。
- 读取快

要么反序列化一串bytes，这个bytes可以是读本地文件或者网上down下来，读完之后bytes销毁

- 加载效率取决于反序列化速度。JSON很慢，用ProtoBuf更快。但是ProtoBuf不好生成二进制文件。
- 占内存，反序列化后的表常驻内存中。
- 读取快



## 如果是随用随读

不再放到内存中，转为随用随取

有一串bytes，在内存中

需要读哪张表的哪个字段，直接取内存中取，然后返回。

- 会慢点
- 省内存 内存占用是二进制序列化之后的



# 遇到的问题

先把txt表转成json存储，

然后用Bson将json反序列化出运行时对象



## 现在的ProtoBuf加载表的流程是

- 要加载某个表testTable
- txt手动转成json
- 用Bson把json反序列化为运行时对象
- **下面三步不需要**
- 用ProtoBuf把运行时对象转成bytes数组
- 先读这个表的二进制文件 File.ReadAllBytes(*.bytes)
- 然后通过反序列化 ProtobufHelper.Deserialize(tableType,bytes) 得到一个object 再把object强转成对应的class
- **上面三步不需要**
- 然后通过class的Get(int id)等等方法来得到

## FlatBuffer流程

txt -> 手动转.fbs描述文件

txt -> 手动.json数据集合

flatc --csharp fbs 生成代码

flatc --binary fbs json 生成二进制.bin集合

但是protobuf不行



# 可能的问题

- 字符串存储\t\r会不会影响分隔符？不会，分隔符用的是特殊字符，手动输入的\t是两个普通的字符。







